---
title: "Step_1_Collection"
author: "DG"
date: "July 6, 2023"
output:
  html_document:
    code_folding: hide
editor_options: 
  markdown: 
    wrap: 70
---

<style type="text/css">
  body{
  font-size: 13pt;
}
</style>



```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## SECTION 1 LOAD DATA, CLEAN DATA

A lot of the debugging is necessary because I added decks in weird
ways, Anki is being constantly developed, and I use many addons.

Load Anki's sqlite database and turn it into several R tables.

```{r Load Ankis SQlite DB}
options(max.print=200) 

require(DBI)
#CHANGEME
COLLECTION_PATH <- "collection.anki2"
connection <- dbConnect(RSQLite::SQLite(), dbname=COLLECTION_PATH)
rev <- dbGetQuery(connection,'SELECT * FROM revlog')

#?dbGetQuery
each.table <- dbListTables(connection)
al<-list(each.table)
for (i in each.table) {
  try({
  eh<-dbGetQuery(connection,(paste0('SELECT * FROM ',i)))
  al[[which(each.table==i)]]<-NA
  names(al)[[which(each.table==i)]] <- i
  al[[which(each.table==i)]]<-eh
  })
} 
names(al)
dbDisconnect(connection)
{
print("following tables did not load properly")
print(each.table[!(each.table %in%  names(al))])
}
note<-al$notes
cards<-al$cards
dek<-al$decks
#names(dek)
#head(dek$id)
```

Basic history plots and info. Maybe reveal bug.

```{r plot simple use history}
 milli_to_date <- function(mili) as.Date((mili)/(24*60*60*1000), origin = "1970-01-01")
reviews.per.card <- sort(table(rev$cid),decreasing = T)
hist(reviews.per.card,breaks = 60)
cards.reviewed.each.month <- milli_to_date(rev$id)
hist(cards.reviewed.each.month,breaks = 60)

{
print("reviews")
print(length(rev$cid))
print("cards reviewed at least once")
print(length(unique(rev$cid)))
print(paste("when was last review:",milli_to_date(max(rev$id,na.rm=T)))) 
print(paste("when was first review:",milli_to_date(min(rev$id,na.rm=T))))
}
```

All id are the timestamp in miliseconds of objects creation or occurence. Card and note ids are universal based on ankiweb (? i never synced) and so are not meaningful variables. This is good because cid can now be used as purely join key. The two timestamps are very similar. Card is the 'side' of a note, ex. one specific empty spot in a cloze deletion phrase. "The number of new cards you have added" in anki's stats window, uses nid or cid. According to it, I started my collection 12 years ago, which is not even close to true. For determining when something was added to collection I will use DID (deck). When card was reviewed is called id in rev data frame.

```{r load tidyverse silently, include=FALSE}
require(tidyverse, quietly = T)
require(ggraph, quietly = T)
require(tidygraph, quietly = T)
```

```{r note and card ids are not useful}
#Source of coding error are the two data tables with redundancy though I am too lazy to fix this mistake now!

#this part may better belong in 'merge all' block
names(note)[1] <- "nid"
names(note)[names(note)=="flds"] <- "card.txt"
names(cards)[1] <- "cid"
names(dek)[1] <- "did"
names(dek)[2] <- "dek.nam" 

hist(milli_to_date(cards$cid),100)
hist(milli_to_date(note$nid),100)
```



Merge all useful info into a single object (sheet). Bug checks too. 

```{r merge most data into single structure}
{
print(paste("percent card's note id in note's ids:",
            round(sum(cards$nid %in% note$nid)/length(cards$nid),3)))
print(paste("percent note's note id in card's ids:",
            round(sum(note$nid %in% cards$nid)/length(note$nid),3)))
cards<-merge(cards,note[,c("nid","card.txt")],all.x = T,all.y=F)
print(paste("percent card's deck id in deck's ids :",
            round(sum(cards$did %in% dek$did)/length(cards$did),3)))
print(paste("percent deck's deck id in card's ids :",
            round(sum(dek$did %in% cards$did)/length(dek$did),3)))
print("umm decks without cards?? deleted decks?")
crd<-merge(cards,dek[,1:2],all.x = T,all.y=F)

#names(crd)
print(paste("percent review's card id in card's ids :",
            round(sum(rev$cid %in% cards$cid)/length(rev$cid),3)))
print("this is probably percent 1 - percent of cards deleted")
print(paste("percent cards's card id in review's ids :",
            round(sum(cards$cid %in% rev$cid)/length(cards$cid),3)))
print(paste("caluclated by ",round(sum(cards$cid %in% rev$cid),3)," / ", round(length(cards$cid),3)))
print("this is just percent of cards ever reviewed and not a bug")
rev2<-merge(rev,crd,all.x = T,all.y=F,by="cid")
}
stopifnot(
  dim(crd)[1]==dim(cards)[1],
  dim(rev)[1]==dim(rev2)[1])

rev<-rev2
rm(rev2);
#Note to self: some cards are removed later because of terrible deck id.
```
Anki's own statistics say cards unseen are .244 percent or (56832 - 42990) 13842 / 56832 . It counts notes not cards. See Section 3.


Convert out of int64 because R works more reliably with 'numeric'.

```{r convert revs ids out of int64}
rev <- rev[order(rev$id),]
least_rev_id <- min(rev$id)
rev$idn <- as.numeric(rev$id)

{
print(paste("converted ids same as unconverted:",all(rev$id == rev$idn)))
print(paste("conversion to numeric unsuccesfull:",sum((rev$id - rev$idn) != 0)))
print(paste("when was last review:",milli_to_date(max(rev$idn,na.rm=T)))) 
}

rev$id  <- as.numeric(rev$id) 

rev$idn <- NULL
rev$cid <- as.numeric(rev$cid)
rev$did <- as.numeric(rev$did)
rev$nid <- as.numeric(rev$nid)
#summary(rev)
#str(rev)


```
Later on reps column in crd will not agree with reviews because many reviews will have been deleted for error correction. If u see any deck names just bellow, that means reviews and reps already disagree which is a bug.
```{r what is reps really}
crd$in_rev <- as.numeric(crd$cid) %in% rev$cid
if( !all((crd$reps>0) == crd$in_rev)){
summary(crd$reps>0)
summary(crd$in_rev)

summary(reviews.lost <- (crd$reps>0 & !crd$in_rev))
unique(crd$dek.nam[reviews.lost])
summary(reps.reset <- (!crd$reps & crd$in_rev))
unique(crd$dek.nam[reps.reset])
}
```

Remove useless columns
```{r remove useless columns}

#summary(rev)
to.delet <- c(
"odid",
"usn",
"usn.x",
"usn.y",
"ivl.y",
"factor.y",
"type.y")

for(i in to.delet){#i="odid"
  rev[,i] <- NULL
} 
#IVL factor and type
```
Remove rows with nas. 
In my case these were almost certainly reviews of deleted cards.
```{r remove rows with nas}
{
  #require(naniar)
require(visdat, quietly = T)

rowrm <- apply(rev,1,function(x) any(is.na(x)))

print(paste("number of rows with na which will be removed",sum(rowrm)))
print("this is likely because of missing ids during join")

print(vis_miss(rev[rowrm,], cluster = TRUE))
rev <- rev[!rowrm,]
}
```


Find duplicate card text and card ids from Reviews. Up to user to do something about it. Anki has duplicates finder but its for power users.
```{r duplicate card text}

#crd <- crd[order(crd$nid),]
#crd$ohno <- duplicated(crd$card.txt) + duplicated(crd$card.txt, fromLast = TRUE)
#print(crd[crd$ohno>0,])

rev<-rev[order(rev$card.txt),]
list.of.rev<-rev %>% 
  group_by(card.txt) %>%
   summarise(dif.nid=n_distinct(nid),
             deck=first(dek.nam),deck2=last(dek.nam)) %>%
  filter(dif.nid>1) 
if(dim(list.of.rev)[1]>0){
print("Duplicate Card Text")
print(unique(c(list.of.rev$deck,list.of.rev$deck2)))
print((list.of.rev[,c(1)]) )
}
 
list.of.rev.idd<-rev %>% 
  group_by(nid) %>%
   summarise(dif.nid=n_distinct(card.txt),
             deck=first(dek.nam),deck2=last(dek.nam)) %>%
  filter(dif.nid>1)  
if(dim(list.of.rev.idd)[1]>0){
print("Multiple IDs per cardtext")
print(unique(c(list.of.rev.idd$deck,list.of.rev.idd$deck2)))
print((list.of.rev.idd[,c(1)]) )
}


```

Duplicates in entire collection.
```{r more duplicate cards}
dup <- crd %>% 
  group_by(card.txt) %>%
  summarise(c.count=length(unique(nid)),
            deck=last(dek.nam)) %>%
  filter((c.count)>1)
  
# to.pretty <- sort(table(dup$deck),decreasing=T)
# as.data.frame(list(dek=names(to.pretty),count=to.pretty))
as_tibble(as.data.frame(sort(table(dup$deck),decreasing=T)))
dup[,c(1)]
```

Quick check.
```{r check test}
rev <- rev[order(rev$id),]
{
# print('all id are the timestamp in miliseconds of objects creation or occurence')
 print(paste("when was last review:",milli_to_date(max(rev$id,na.rm=T)))) 
 print(paste("which rev ids na:",which(is.na(rev$id))))
 print(paste("which rev ids are duplicated:",which(duplicated(rev$id))))
 print(paste("any timings reverse order or lags become zero:",which(diff(rev$id)<=0)))
# print("no more NAs and no more int64s either")
#summary(rev)
#str(rev)
}
```
Quick check of card table.
```{r quick check of card table}
{
print("following regards card data table")
print(paste("count of unique card text",length(unique(crd$card.txt))))
print(paste("count of unique note ids",length(unique(crd$nid))))
print("difference between the above two values is number of duplicate cards")
print(paste("count of unique card ids",length(unique(crd$cid))))
print(paste("dimensions of card object",paste(dim(crd),collapse = " ")))
}
```




## SECTION 2 TIMESTAMP MISSALIGNMENT 

```{r reviews and cards per deck}
#reviews and cards per deck into Reviews 
rev <- rev %>%
  group_by(dek.nam) %>%
   mutate(cards.in.dek=n_distinct(cid),
             revs.in.dek=n())%>%
  arrange(id)%>%
  ungroup()
```

Fix ids that are way too early to be timestamps.
CHANGEME Code here only fixes deck-ids. If output bellow is not "rev 0 card 0 note 0" post to github.

```{r fix non timestamp ids}
print(paste0("count of IDs too low to be timestamps. rev ", sum(rev$id<10000)," card ", sum(rev$cid<10000), " note ",sum(rev$nid<10000), " deck ", sum(rev$did<10000)))


if(any(rev$did<100)){
  print(("names of weird decks the Id of which is not timestamp"))
  print((unique(rev$dek.nam[rev$did<10])))
  print(paste("number of reviews in weird decks",sum(rev$did<10)))
  print(paste("first,last rev in those decks",
              milli_to_date(rev$id[rev$did<10][1]),
              milli_to_date(rev$id[rev$did<10][sum(rev$did<10)])))
  if(sum(rev$did<10) < dim(rev)[1]*.005){
  print("looks not too bad in this case so deck will be deleted")
  #print(unique(rev$card.txt[rev$did==1]))
  rev<-rev[rev$did>10,]
  crd<-crd[crd$did>10,]
  }
  else{
    print("too many reviews so deck id stamp will be set near to median")
    warning("code untested")
    while(any(rev$did<1000)){
    medek<-median(sort(as.numeric(cards$did)))
    print(unique(rev$dek.nam[rev$did==medek]))
    while((medek %in% rev$did) || 
          (medek %in% rev$id) || 
          (medek %in% rev$cid)) medek<-medek+1
    rev$did[min(rev$did)]<-medek
    crd$did[min(rev$did)]<-medek
    }
  }
}
```
```{r disorder in timestamps of card-deck-review }
{
print(paste("total revs left:",dim(rev)[1]))
if(sum(rev$cid>rev$id)>0) print(paste("number reviews with card created after review somehow CHANGEME",sum(rev$cid>rev$id)))
#if(sum(rev$did>(rev$cid))>0) print(paste("number reviews with deck created after card somehow",sum(rev$did>(rev$cid-10))))
#as established cid is not relevant
  
rev$time.missalign=rev$did>rev$id
if(sum(rev$time.missalign)>0) print(paste("number reviews with deck created after review somehow",sum(rev$time.missalign)))
}

```

In my database most reviews before deck creation were caused by an Anki upgrade changed them. TODO (likely problematic) They should be fixed by undoing the change but currently just deleted. Also some of the decks were installed in a weird way and kept the makers review history. These reviews will be deleted. One case was probably caused by editing a card and should be ignored. Could moving cards between decks cause this problem too?

Following code removes reviews made before the deck timestamp and reviews made
before a certain date. Deck ids will be increased.

CHANGEME U may want to change which of the 4 removal methods activate by altering the Ts and Fs. Remove specific decks. Remove reviews before their deck's timestamp. Remove reviews before a certain time set in 'first_time_used_anki'. Change deck id to after anki is used first time. 

```{r find and remove problem reviews and decks}
{
#remove some specific decks 
if(F){
library(stringr)
rev<-rev[!str_detect(rev$dek.nam,
              stringr::fixed("ProgramingAdvancedWide")),]
rev<-rev[!str_detect(rev$dek.nam,
              stringr::fixed("Paper Recursive Feedback")),]

crd<-crd[!str_detect(crd$dek.nam,
              stringr::fixed("ProgramingAdvancedWide")),]

rev %>%
  arrange(id) %>%
  group_by(dek.nam) %>%
  arrange(id) %>%
   summarise(cards.in.dek=n_distinct(cid),
             revs.in.dek=n())%>%
  arrange(desc(cards.in.dek))
}
#remove reviews before their decks
if(T){
  rev$time.missalign=rev$did>rev$id
  print(" ")
print(paste("number reviews with deck created after review to be deleted", sum(rev$time.missalign)))
print(as_tibble(as.data.frame(table(rev[rev$time.missalign,]$dek.nam))))
  rev <- rev[!rev$time.missalign,]
}
#remove reviews before a certain time
if(T){
  first_time_used_anki <- 1.548563e+12
  to_fix <- rev$id<first_time_used_anki
  print(paste("number reviews before ",milli_to_date(first_time_used_anki)," to be deleted ",  sum(to_fix)))
  print(as_tibble(as.data.frame(table(rev[to_fix,]$dek.nam))))
rev <- rev[!to_fix,] 
}

#move deck id to better a point in time 
if(T){
  deks_to_fix <- unique(crd[crd$did<first_time_used_anki,]$dek.nam)
  print(" ")
  print("deck id timestamps updated to about anki first use ")
  print(deks_to_fix[1:5])
  #real_first_use <- (min(rev$id))
  subtract_mseconds <- 0
  for(i in deks_to_fix){
    subtract_mseconds <- subtract_mseconds + 60000
    while((subtract_mseconds %in% rev$did) || 
     (subtract_mseconds %in% rev$id) || 
     (subtract_mseconds %in% rev$cid)) subtract_mseconds<-subtract_mseconds+1
    rev[rev$dek.nam==i,]$did <- first_time_used_anki - subtract_mseconds
    crd[crd$dek.nam==i,]$did <- first_time_used_anki - subtract_mseconds
  }
}
}
```



Review id timestamps after trimming
```{r review id timestamps after trimming}
{
rev <- rev[order(rev$id),]
print(paste("when was first review:",milli_to_date(min(rev$id,na.rm=T))))
print(paste("when was last review:",milli_to_date(max(rev$id,na.rm=T)))) 
print(paste("which rev ids na:",which(is.na(rev$id))))
print(paste("which rev ids are duplicated:",which(duplicated(rev$id))))
print(paste("dimensions of review and card decks ", paste(c(dim(rev),dim(crd)),collapse = " ")))
print(paste("different cards ever reviewd", length(unique(rev$cid))))
print(paste("different notes ever reviewd", length(unique(rev$nid))))

}
```

```{r check after crit clean}
#Review table grouped by card.txt. End user need not bother with it.
if(F){
revie.deck.mis <- rev %>%  
  group_by(card.txt) %>%
   summarise(deck.name = first(dek.nam),
             revs.before.deck = sum(did>id),
             revstotal = n(),
             first.rview = first(id),
             deck.date = first(did)) %>%
  group_by(deck.name) %>%
   summarise(cardstotal=n(),
            cards.ever.before.deck = sum(revs.before.deck > 1), 
            revs.total = sum(revstotal), 
            revs.before.deck= sum(revs.before.deck),
             first.review=milli_to_date(first(first.rview)),
             deck.date=milli_to_date(first(deck.date))) %>%
  mutate(percent.new=revs.before.deck / revs.total) 

print(revie.deck.mis[order(revie.deck.mis$first.review),])
#summary(rev)
#str(rev)
}
```



## SECTION 3 COLLECTION STRUCTURE AND ACCUMULATION
 

```{r new plot of cards each month}
{
reviews.after.clean <- milli_to_date(rev$id)
hist(reviews.after.clean, breaks = 60)
# cards$created_date <- as.yearmon(anydate(as.numeric(cards$cid)/1000))
# cards_summary <- sqldf("select created_date, count(*) as n_cards from cards group by created_date order by created_date")
percent_unseen <- round(digits=3,sum(as.numeric(crd$nid) %in% rev$nid)/length(as.numeric(crd$nid)))
print(paste("percent notes actualy ever tried",percent_unseen
))
print(paste("calculated as ",
            sum(as.numeric(crd$nid) %in% rev$nid),
                                 '/',length(as.numeric(crd$nid))
))
if(percent_unseen<.5) print("looks like user has been making too many plans")

if(T){
rev <- rev[order(rev$id),]
rev$first.rev.of.a.note<-(!duplicated(rev$nid))

reved <- rev %>%
  group_by(nid) %>%
  summarise(min=min(id)) %>%
  arrange(min) %>% ungroup()
print(paste("number of reviews before notes", sum(reved$nid >= reved$min)))

#print(paste("both calculation methods agree",length(reved$min)==length(rev$id[rev$first.rev.of.a.note])))
}
}
```



```{r accumulation of cards in time}
nts_fg <- crd$did[!duplicated(crd$nid)]
nts_gd <- (crd$did[!duplicated(crd$nid) & (as.numeric(crd$nid) %in% rev$nid)])

ggplot()+
  geom_histogram(aes(x=milli_to_date(rev$id),color=!rev$first.rev.of.a.note),binwidth = 60)+
  geom_point(aes(x=milli_to_date(nts_fg),cumsum(rep(1,times=length(nts_fg))),
                 color="cum notes in collection"))+
  geom_point(aes(x=milli_to_date(nts_gd),cumsum(rep(1,times=length(nts_gd))),
                 color="cn in coll, actualy used"))+
  geom_point(aes(x=milli_to_date(rev$id[rev$first.rev.of.a.note]),
                 cumsum(rep(1,times=length(rev$id[rev$first.rev.of.a.note]))),
                 color="cum notes seen"))+
  xlab("Date") + ylab("Histogram is of reviews of old and new cards")+ 
  ggtitle( "Points as cumulative sum of notes")+
  scale_x_date(date_breaks="6 months")+ 
  theme( axis.text.x = element_text(angle=30) )+
  labs(colour = " ")

ggplot()+
  geom_histogram(aes(x=milli_to_date(rev$id),color=!rev$first.rev.of.a.note),binwidth = 60)+
  geom_point(aes(x=milli_to_date(nts_gd),cumsum(rep(1,times=length(nts_gd))),
                 color="cn in coll, actualy used"))+
  geom_point(aes(x=milli_to_date(rev$id[rev$first.rev.of.a.note]),
                 cumsum(rep(1,times=length(rev$id[rev$first.rev.of.a.note]))),
                 color="cum notes seen"))+
  xlab("Date") + ylab("Histogram is of reviews of old and new cards")+ 
  ggtitle( "Points as cumulative sum of notes")+
  scale_x_date(date_breaks="6 months")+ 
  theme( axis.text.x = element_text(angle=30) )+
  labs(colour = " ")

```

The TRUE is reviews of cards already reviewed and FALSE is reviews of
new notes. A two sided note will make 2 cards like hand -\> mano and
mano -\> hand. Anki already has similar plot.

When were cards added that have ever been reviewed? Good and bad decisions?
```{r good decisions when adding decks}
qdf <- data.frame(dion = c(nts_fg, nts_gd),
                  seen=c(rep(F,times=length(nts_fg)),rep(T,times=length(nts_gd))))

ggplot(data=qdf)+
  geom_histogram(aes(x=milli_to_date(dion),fill= seen),binwidth = 60)+
  scale_x_date(date_breaks="6 months")+ 
  theme( axis.text.x = element_text(angle=30) )+
  xlab("Date")+ 
  ggtitle( "When were notes added that were ever reviewed")

```



Cleaning text function.   Clean deck names as well as card text.
```{r clean deck names}
require(stringr, quietly = T)
clean_strings <- function(ws,remove.digits=T){
ws <- gsub(pattern = '\037'," -- ",ws,fixed = T)
ws <- gsub(pattern = '<img src='," AN_IMAGE_HERE<  ",ws,fixed = T)
ws <- gsub(pattern = '<.+?>'," ",ws,fixed = F)
ws <- gsub(pattern = '\\[.+?\\]'," ",ws,fixed = F)
ws <- gsub(pattern = '{{c'," ",ws,fixed = T)
ws <- gsub(pattern = '::',":",ws,fixed = T)
ws <- gsub(pattern = '}}'," ",ws,fixed = T)
if(remove.digits){
  ws <- gsub(pattern = '[[:digit:]][[:digit:]][[:digit:]]+'," % ",ws,fixed = F)
}
ws <- gsub(pattern = 'nbsp'," ",ws,fixed = T)
ws <- gsub(pattern = '/n'," ",ws,fixed = T)
ws <- str_squish(ws)
} 

if(T){
 
deck_count <- (unique(rev$dek.nam))
deck_count_crd <- (unique(crd$dek.nam))

crd$dek.nam.old <- crd$dek.nam
crd$dek.nam <- sapply(crd$dek.nam,clean_strings,remove.digits=F)

rev$dek.nam.old <- rev$dek.nam
rev$dek.nam <- sapply(rev$dek.nam,clean_strings,remove.digits=F)
 
deck.names.redun <- length(deck_count) - length(unique(rev$dek.nam))
print(paste0("count of deck names ",deck.names.redun," made identical by string cleaning in rev"))
deck.names.redun.crd <- length(deck_count_crd) - length(unique(crd$dek.nam))
print(paste0("count of deck names ",deck.names.redun.crd ," made identical by string cleaning in crd"))
 
if(deck.names.redun.crd>0) {
  print("this is a problem; please edit the names of the following decks")
  crd %>% 
    group_by(dek.nam) %>%
    summarize(length(unique(did)))
}
}

if(T){ 
card_count <- length(unique(rev$card.txt))
card_count_crd <- length(unique(crd$card.txt))

crd$card.txt.old <- crd$card.txt
crd$card.txt <- sapply(crd$card.txt,clean_strings,remove.digits=F)

rev$card.txt.old <- rev$card.txt
rev$card.txt <- sapply(rev$card.txt,clean_strings,remove.digits=F) 
deck.names.redun <- card_count - length(unique(rev$card.txt))
print(paste0("count of card.txt ",deck.names.redun," made identical by string cleaning in rev"))
deck.names.redun.crd <- card_count_crd - length(unique(crd$card.txt))
print(paste0("count of card txt ",deck.names.redun.crd ," made identical by string cleaning in crd"))
 
}
```

```{r count cards in deck; simple deck name; add var to rev}

crd$simplest.name <- apply(crd, 1, function(x){
  levs<-str_split(x[names(x)=="dek.nam"],stringr::fixed("--"))[[1]]
  return(levs[length(levs)])
} )


rev$simplest.name <- apply(rev, 1, function(x){
  levs<-str_split(x[names(x)=="dek.nam"],stringr::fixed("--"))[[1]]
  return(levs[length(levs)])
} )

opp <- crd %>%  
  group_by(simplest.name) %>% 
  summarise(Cards_in_deck = n()) 

#stopifnot("final names of decks in reviews not in deck data.frame" = all(rev$simplest.name %in% opp$simplest.name))

any.odd.changes <- dim(rev) 

rev <- merge(rev,opp,all.x = T,all.y=F , by ="simplest.name")

stopifnot("number rows changed after merge" = dim(rev)[1]==any.odd.changes[1],
  "number columns changed after merge" = (dim(rev)[2])==(any.odd.changes[2]+1))

```

```{r decks by card count and usage}
#require(treemapify)
require(treemap, quietly = T)
require(grDevices, quietly = T)
 
opp <- crd %>%  
  group_by(simplest.name) %>% 
  summarise(
            Cards_in_deck = n(), 
            did = first(did),
            seen.once = sum(as.numeric(cid) %in% rev$cid)
  ) %>%
  mutate(
    percent_reviewed = (seen.once / Cards_in_deck),
    Sqrt.cards.in.deck = sqrt(Cards_in_deck),
    sqrt.cards.seen.once = sqrt(seen.once)
  )

#dim(opp)
#summary(opp)

treemap(opp, index="simplest.name", vSize="Cards_in_deck", vColor="percent_reviewed", type="manual", palette="RdYlBu")
 # itreemap(opp)
  
  treemap(opp, index="simplest.name", vSize="sqrt.cards.seen.once", vColor="percent_reviewed", type="manual", palette="RdYlBu")

```

TODO animate over time events of great addition? 
TODO interactive sunburst? Or does anki with addons do this better?

Separate folder path into each folder name. First rev then crd. Check if one folder name appears in another hierarchy level. Up to user to fix.

```{r separate tree}
dek_name_to_heir <- function(var.to.split){
split_str <- str_split(var.to.split,stringr::fixed("--"))
pre_padded_df <- sapply(split_str, simplify="matrix",function(x){
  for(i in 1:(20-length(x))) x<-c(x,"")
return(x)
}) 
dek_heir_padded <- as.data.frame(t(pre_padded_df))
levels_not_empty <- (apply(dek_heir_padded, 2, 
                           function(x) length(unique(x)))!=1)
dek_heir_padded <- dek_heir_padded[,levels_not_empty]
max_lv <<- dim(dek_heir_padded)[2]
for(i in (max_lv):1) names(dek_heir_padded)[i] <- paste0("dek.heir.lev.",i)
return(dek_heir_padded)
}
dek_heir_unfurled <- dek_name_to_heir(rev$dek.nam)
#print(dek_heir_unfurled)
rev <- cbind(rev,dek_heir_unfurled)

for(itr in 1:(max_lv-1)){#itr<-1
  for(i in (max_lv-itr):1){#i<-1
    wish <- (unique(rev[,paste0("dek.heir.lev.",i)]) %in%                 unique(rev[,paste0("dek.heir.lev.",i+itr)]))
  #print(wish)
    itsy<-unique(rev[,paste0("dek.heir.lev.",i)])[wish]
    if(length(itsy)>0) if(any(nchar(itsy)>0)) print(paste("duplicate deck names ",itsy))
  }}

dek_heir_unfurled <- dek_name_to_heir(crd$dek.nam)
#print(dek_heir_unfurled)
crd <- cbind(crd,dek_heir_unfurled)

for(itr in 1:(max_lv-1)){#itr<-1
  for(i in (max_lv-itr):1){#i<-1
    wish <- (unique(crd[,paste0("dek.heir.lev.",i)]) %in%                 unique(crd[,paste0("dek.heir.lev.",i+itr)]))
  #print(wish)
    itsy<-unique(crd[,paste0("dek.heir.lev.",i)])[wish]
    if(length(itsy)>0) if(any(nchar(itsy)>0)) print(paste("duplicate deck names ",itsy))
  }}

```



```{r deck folder heirarchy}
{
dx <- c("dek.heir.lev.1"  ,   
 "dek.heir.lev.2"   ,   "dek.heir.lev.3" ,    
 "dek.heir.lev.4"   ,   "dek.heir.lev.5" ,    "dek.heir.lev.6")
revgrp <- rev[,c(dx)]
#names(rev)
revgrp <- revgrp[!duplicated(revgrp),]
lvone <- unique(revgrp[,(1)])
edges <- data.frame(from=rep("root",length(lvone)),to=lvone)
edges <- data.frame(from=c(),to=c())
for(i in 2:dim(revgrp)[2]){ #i<-2
  hold <- data.frame(from= revgrp[,(i-1)], to= revgrp[,(i)])
  edges <- rbind(edges,hold)
}
#names(edges)
edges <- edges[edges$to!="",]
nodes <- data.frame(node_key =unique(unlist(edges)))
g <- tbl_graph(edges=edges, directed=TRUE, nodes=nodes)
yout <- create_layout(g, layout = 'igraph', algorithm = 'fr' )
ggraph(g,layout=yout) + 
  geom_edge_link(alpha=.2) + 
  geom_node_point(size=2,color="red") +
  geom_node_text(aes(label = node_key),
                 repel=T,size=2)#angle=10,

#require(reactable)
#?reactable
}
```

Plot of deck folder hierarchy above. 


Folders with cards as well as decks. Maybe make the bellow mentioned decks not hold both cards and decks by moving the decks? (if move cards may cause problems!)
```{r any folders with cards as well as decks?}
#um find every unique full deck name then check if it is part of any others and then that full deck name will be one with 


dek.evey <- sort(unique(crd$dek.nam))
logh <- str_split(dek.evey,stringr::fixed("--"))

nonlastset<-c()
for(i in 1:4){
huh<-lapply(logh,function(x){ #x<-logh[[6]]
  (try(silent = T,{x <- x[1:(length(x)-i)]
  return(
    paste(x,collapse = "--")
  )
  }))
  return("")
})
nonlastset<-unique(c(nonlastset,unlist(huh)))
}
crd$notendfolder <- crd$dek.nam %in% nonlastset
crd %>% filter(notendfolder) %>% group_by(dek.nam) %>% summarise(count= n())
 
```
 

Check that duplicate columns in crd and rev have not diverged. 
```{r check crd and rev redundancies are identical}
{
cols <- names(crd)[names(crd) %in% names(rev)]
#print(cols)
tocompare <- rev[!duplicated(rev$cid),cols]
tocompare <- tocompare[order(tocompare$cid),]
crd_compare <- crd[order(crd$cid),cols]
crd_compare <- crd_compare[as.numeric(crd_compare$cid) %in% tocompare$cid,]
crd_compare$did <- as.numeric(crd_compare$did )
crd_compare$cid <- as.numeric(crd_compare$cid )
crd_compare$nid <- as.numeric(crd_compare$nid )

if(nchar(all_equal(crd_compare,tocompare))>10){
  require(arsenal, quietly = T)
  require(diffdf, quietly = T)
  print("redundancies between rev and crd are not aligned this may be a big bug")
  dim(tocompare)
dim(crd_compare)
  #(all_equal(crd_compare,tocompare)[1:20])

print(diffdf(crd_compare,tocompare))

comparedf(crd_compare,tocompare)
}
}
```

Remove most objects from memory and save the rest into files.
```{r delete remove objects for cleanliness}
saveRDS(rev,"rev.RDS")
saveRDS(crd,"crd.RDS")
if(T){
#rm(cards)
#rm(note)
#rm(crd)
#rm(dek)

rm(list=unlist(setdiff(ls(),c("rev","crd"))))
}
gc()

```
